diff -u openssh-7.1p2/Makefile.in openssh-7.1p2-lpk/Makefile.in
--- openssh-7.1p2/Makefile.in	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/Makefile.in	2016-02-24 16:47:51.000000000 -0800
@@ -110,7 +110,7 @@
 	sftp-server.o sftp-common.o \
 	roaming_common.o roaming_serv.o \
 	sandbox-null.o sandbox-rlimit.o sandbox-systrace.o sandbox-darwin.o \
-	sandbox-seccomp-filter.o sandbox-capsicum.o
+	sandbox-seccomp-filter.o sandbox-capsicum.o ldapauth.o
 
 MANPAGES	= moduli.5.out scp.1.out ssh-add.1.out ssh-agent.1.out ssh-keygen.1.out ssh-keyscan.1.out ssh.1.out sshd.8.out sftp-server.8.out sftp.1.out ssh-keysign.8.out ssh-pkcs11-helper.8.out sshd_config.5.out ssh_config.5.out
 MANPAGES_IN	= moduli.5 scp.1 ssh-add.1 ssh-agent.1 ssh-keygen.1 ssh-keyscan.1 ssh.1 sshd.8 sftp-server.8 sftp.1 ssh-keysign.8 ssh-pkcs11-helper.8 sshd_config.5 ssh_config.5
Only in openssh-7.1p2-lpk: README.lpk
diff -u openssh-7.1p2/auth-rsa.c openssh-7.1p2-lpk/auth-rsa.c
--- openssh-7.1p2/auth-rsa.c	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/auth-rsa.c	2016-02-24 16:25:03.000000000 -0800
@@ -176,6 +176,93 @@
 	FILE *f;
 	u_long linenum = 0;
 	Key *key;
+#ifdef WITH_LDAP_PUBKEY
+	ldap_key_t * k;
+	unsigned int i = 0;
+#endif
+
+#ifdef WITH_LDAP_PUBKEY
+	/* here is the job */
+	key = key_new(KEY_RSA1);
+
+	if (options.lpk.on) {
+	    debug("[LDAP] trying LDAP first uid=%s", pw->pw_name);
+	    if ( ldap_ismember(&options.lpk, pw->pw_name) > 0) {
+		if ( (k = ldap_getuserkey(&options.lpk, pw->pw_name)) != NULL) {
+		    for (i = 0 ; i < k->num ; i++) {
+			char *cp, *options = NULL;
+
+			for (cp = k->keys[i]->bv_val; *cp == ' ' || *cp == '\t'; cp++)
+			    ;
+			if (!*cp || *cp == '\n' || *cp == '#')
+			    continue;
+
+			/*
+			* Check if there are options for this key, and if so,
+			* save their starting address and skip the option part
+			* for now.  If there are no options, set the starting
+			* address to NULL.
+			 */
+			if (*cp < '0' || *cp > '9') {
+			    int quoted = 0;
+			    options = cp;
+			    for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
+				if (*cp == '\\' && cp[1] == '"')
+				    cp++;	/* Skip both */
+				else if (*cp == '"')
+				    quoted = !quoted;
+			    }
+			} else
+			    options = NULL;
+
+			/* Parse the key from the line. */
+			if (hostfile_read_key(&cp, &bits, key) == 0) {
+			    debug("[LDAP] line %d: non ssh1 key syntax", i);
+			    continue;
+			}
+			/* cp now points to the comment part. */
+
+			/* Check if the we have found the desired key (identified by its modulus). */
+			if (BN_cmp(key->rsa->n, client_n) != 0)
+			    continue;
+
+			/* check the real bits  */
+			if (bits != (unsigned int)BN_num_bits(key->rsa->n))
+			    logit("[LDAP] Warning: ldap, line %lu: keysize mismatch: "
+				    "actual %d vs. announced %d.", (unsigned long)i, BN_num_bits(key->rsa->n), bits);
+
+			/* We have found the desired key. */
+			/*
+			* If our options do not allow this key to be used,
+			* do not send challenge.
+			 */
+			if (!auth_parse_options(pw, options, "[LDAP]", (unsigned long) i))
+			    continue;
+
+			/* break out, this key is allowed */
+			allowed = 1;
+
+			/* add the return stuff etc... */
+			/* Restore the privileged uid. */
+			restore_uid();
+
+			/* return key if allowed */
+			if (allowed && rkey != NULL)
+			    *rkey = key;
+			else
+			    key_free(key);
+
+			ldap_keys_free(k);
+			return (allowed);
+		    }
+		} else {
+		    logit("[LDAP] no keys found for '%s'!", pw->pw_name);
+		}
+	    } else {
+		logit("[LDAP] '%s' is not in '%s'", pw->pw_name, options.lpk.sgroup);
+	    }
+	}
+#endif
 
 	debug("trying public RSA key file %s", file);
 	if ((f = auth_openkeyfile(file, pw, options.strict_modes)) == NULL)
diff -u openssh-7.1p2/auth2-pubkey.c openssh-7.1p2-lpk/auth2-pubkey.c
--- openssh-7.1p2/auth2-pubkey.c	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/auth2-pubkey.c	2016-02-24 16:25:03.000000000 -0800
@@ -69,6 +69,10 @@
 #include "channels.h" /* XXX for session.h */
 #include "session.h" /* XXX for child_set_env(); refactor? */
 
+#ifdef WITH_LDAP_PUBKEY
+#include "ldapauth.h"
+#endif
+
 /* import */
 extern ServerOptions options;
 extern u_char *session_id2;
@@ -909,6 +913,91 @@
 	return found_key;
 }
 
+#ifdef WITH_LDAP_PUBKEY
+/*
+ * Checks whether key is allowed in ldap.
+ * returns 1 if the key is allowed or 0 otherwise.
+ */
+static int
+user_key_ldap_allowed2(struct passwd *pw, Key *key)
+{
+	int found_key = 0;
+	u_long linenum = 0;
+	Key *found = NULL;
+	ldap_key_t * k = NULL;
+	unsigned int i = 0;
+	char *fp = NULL;
+	char file[9] = "LDAP key";
+
+	/* Temporarily use the user's uid. */
+	temporarily_use_uid(pw);
+
+	/* allocate a new key type */
+	found = key_new(key->type);
+
+	debug("[LDAP] trying LDAP first uid=%s",pw->pw_name);
+	if (ldap_ismember(&options.lpk, pw->pw_name) > 0) {
+		if ((k = ldap_getuserkey(&options.lpk, pw->pw_name)) != NULL) {
+			/* Skip leading whitespace, empty and comment lines. */
+			for (i = 0 ; i < k->num ; i++) {
+				/* dont forget if multiple keys to reset options */
+				char *cp, *options = NULL;
+
+				for (cp = (char *)k->keys[i]->bv_val; *cp == ' ' || *cp == '\t'; cp++)
+					;
+				if (!*cp || *cp == '\n' || *cp == '#')
+					continue;
+
+				if (key_read(found, &cp) != 1) {
+					/* no key?  check if there are options for this key */
+					int quoted = 0;
+					debug2("[LDAP] user_key_allowed: check options: '%s'", cp);
+					options = cp;
+					for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
+						if (*cp == '\\' && cp[1] == '"')
+							cp++;   /* Skip both */
+						else if (*cp == '"')
+							quoted = !quoted;
+					}
+					/* Skip remaining whitespace. */
+					for (; *cp == ' ' || *cp == '\t'; cp++)
+						;
+					if (key_read(found, &cp) != 1) {
+						debug2("[LDAP] user_key_allowed: advance: '%s'", cp);
+						/* still no key?  advance to next line*/
+						continue;
+					}
+				}
+
+				if (key_equal(found, key) &&
+					auth_parse_options(pw, options, file, linenum) == 1) {
+					found_key = 1;
+					debug("[LDAP] matching key found");
+					fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
+					verbose("[LDAP] Found matching %s key: %s", key_type(found), fp);
+					goto done;
+				}
+			}/* end of LDAP for() */
+		} else {
+			logit("[LDAP] no keys found for '%s'!", pw->pw_name);
+		}
+	} else {
+	logit("[LDAP] '%s' is not in '%s'", pw->pw_name, options.lpk.sgroup);
+	}
+
+done:
+	/* restoring memory */
+	if (k != NULL)
+		ldap_keys_free(k);
+	if (fp != NULL)
+		free(fp);
+	if (found != NULL)
+		key_free(found);
+	restore_uid();
+	return found_key;
+}
+#endif
+
 /*
  * Checks whether key is allowed in output of command.
  * returns 1 if the key is allowed or 0 otherwise.
@@ -1052,6 +1141,14 @@
 	if (success > 0)
 		return success;
 
+#ifdef WITH_LDAP_PUBKEY
+	if (options.lpk.on) {
+		success = user_key_ldap_allowed2(pw, key);
+		if (success)
+			return success;
+	}
+#endif
+
 	for (i = 0; !success && i < options.num_authkeys_files; i++) {
 
 		if (strcasecmp(options.authorized_keys_files[i], "none") == 0)
diff -u openssh-7.1p2/config.h.in openssh-7.1p2-lpk/config.h.in
--- openssh-7.1p2/config.h.in	2016-01-13 17:13:40.000000000 -0800
+++ openssh-7.1p2-lpk/config.h.in	2016-02-24 16:25:03.000000000 -0800
@@ -730,6 +730,9 @@
 /* Define to 1 if you have the <locale.h> header file. */
 #undef HAVE_LOCALE_H
 
+/* Define if you want LDAP support */
+#undef WITH_LDAP_PUBKEY
+
 /* Define to 1 if you have the `login' function. */
 #undef HAVE_LOGIN
 
diff -u openssh-7.1p2/configure.ac openssh-7.1p2-lpk/configure.ac
--- openssh-7.1p2/configure.ac	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/configure.ac	2016-02-24 16:47:51.000000000 -0800
@@ -1613,6 +1613,37 @@
 	fi
 fi
 
+# Check whether user wants LDAP support
+LDAP_MSG="no"
+AC_ARG_WITH(ldap,
+	[  --with-ldap[[=PATH]]      Enable LDAP pubkey support (optionally in PATH)],
+	[
+		if test "x$withval" != "xno" ; then
+
+			if test "x$withval" != "xyes" ; then
+				CPPFLAGS="$CPPFLAGS -I${withval}/include"
+				LDFLAGS="$LDFLAGS -L${withval}/lib"
+			fi
+
+			AC_DEFINE([WITH_LDAP_PUBKEY], 1, [Enable LDAP pubkey support])
+			LIBS="-lldap $LIBS"
+			LDAP_MSG="yes"
+	
+			AC_MSG_CHECKING([for LDAP support])
+			AC_TRY_COMPILE(
+				[#include <sys/types.h>
+				 #include <ldap.h>],
+				[(void)ldap_init(0, 0);],
+				[AC_MSG_RESULT(yes)],
+				[
+				    AC_MSG_RESULT(no) 
+					AC_MSG_ERROR([** Incomplete or missing ldap libraries **])
+				]
+        	)
+		fi
+	]
+)
+
 dnl    Checks for library functions. Please keep in alphabetical order
 AC_CHECK_FUNCS([ \
 	Blowfish_initstate \
@@ -4929,6 +4960,7 @@
 echo "                   SELinux support: $SELINUX_MSG"
 echo "                 Smartcard support: $SCARD_MSG"
 echo "                     S/KEY support: $SKEY_MSG"
+echo "                      LDAP support: $LDAP_MSG"
 echo "              MD5 password support: $MD5_MSG"
 echo "                   libedit support: $LIBEDIT_MSG"
 echo "  Solaris process contract support: $SPC_MSG"
Common subdirectories: openssh-7.1p2/contrib and openssh-7.1p2-lpk/contrib
Only in openssh-7.1p2-lpk: ldapauth.c
Only in openssh-7.1p2-lpk: ldapauth.h
Only in openssh-7.1p2-lpk: lpk-user-example.txt
Common subdirectories: openssh-7.1p2/openbsd-compat and openssh-7.1p2-lpk/openbsd-compat
Only in openssh-7.1p2-lpk: openssh-lpk_openldap.schema
Only in openssh-7.1p2-lpk: openssh-lpk_sun.schema
Common subdirectories: openssh-7.1p2/regress and openssh-7.1p2-lpk/regress
Common subdirectories: openssh-7.1p2/scard and openssh-7.1p2-lpk/scard
diff -u openssh-7.1p2/servconf.c openssh-7.1p2-lpk/servconf.c
--- openssh-7.1p2/servconf.c	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/servconf.c	2016-02-24 16:47:50.000000000 -0800
@@ -58,6 +58,10 @@
 #include "myproposal.h"
 #include "digest.h"
 
+#ifdef WITH_LDAP_PUBKEY
+#include "ldapauth.h"
+#endif
+
 static void add_listen_addr(ServerOptions *, char *, int);
 static void add_one_listen_addr(ServerOptions *, char *, int);
 
@@ -136,6 +140,26 @@
 	options->num_allow_groups = 0;
 	options->num_deny_groups = 0;
 	options->ciphers = NULL;
+#ifdef WITH_LDAP_PUBKEY
+	/* XXX dirty */
+	options->lpk.ld = NULL;
+	options->lpk.on = -1;
+	options->lpk.servers = NULL;
+	options->lpk.u_basedn = NULL;
+	options->lpk.g_basedn = NULL;
+	options->lpk.binddn = NULL;
+	options->lpk.bindpw = NULL;
+	options->lpk.sgroup = NULL;
+	options->lpk.filter = NULL;
+	options->lpk.fgroup = NULL;
+	options->lpk.l_conf = NULL;
+	options->lpk.tls = -1;
+	options->lpk.b_timeout.tv_sec = -1;
+	options->lpk.s_timeout.tv_sec = -1;
+	options->lpk.flags = FLAG_EMPTY;
+	options->lpk.pub_key_attr = NULL;
+	options->lpk.uid_attr = NULL;
+#endif
 	options->macs = NULL;
 	options->kex_algorithms = NULL;
 	options->protocol = SSH_PROTO_UNKNOWN;
@@ -350,7 +374,36 @@
 	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
 	    &options->pubkey_key_types) != 0)
 		fatal("%s: kex_assemble_names failed", __func__);
-
+#ifdef WITH_LDAP_PUBKEY
+	if (options->lpk.on == -1)
+		options->lpk.on = _DEFAULT_LPK_ON;
+	if (options->lpk.servers == NULL)
+		options->lpk.servers = _DEFAULT_LPK_SERVERS;
+	if (options->lpk.u_basedn == NULL)
+		options->lpk.u_basedn = _DEFAULT_LPK_UDN;
+	if (options->lpk.g_basedn == NULL)
+		options->lpk.g_basedn = _DEFAULT_LPK_GDN;
+	if (options->lpk.uid_attr == NULL)
+		options->lpk.uid_attr = _DEFAULT_LPK_UID;
+	if (options->lpk.binddn == NULL)
+		options->lpk.binddn = _DEFAULT_LPK_BINDDN;
+	if (options->lpk.bindpw == NULL)
+		options->lpk.bindpw = _DEFAULT_LPK_BINDPW;
+	if (options->lpk.sgroup == NULL)
+		options->lpk.sgroup = _DEFAULT_LPK_SGROUP;
+	if (options->lpk.filter == NULL)
+		options->lpk.filter = _DEFAULT_LPK_FILTER;
+	if (options->lpk.tls == -1)
+		options->lpk.tls = _DEFAULT_LPK_TLS;
+	if (options->lpk.b_timeout.tv_sec == -1)
+		options->lpk.b_timeout.tv_sec = _DEFAULT_LPK_BTIMEOUT;
+	if (options->lpk.s_timeout.tv_sec == -1)
+		options->lpk.s_timeout.tv_sec = _DEFAULT_LPK_STIMEOUT;
+	if (options->lpk.l_conf == NULL)
+		options->lpk.l_conf = _DEFAULT_LPK_LDP;
+	if (options->lpk.pub_key_attr == NULL)
+		options->lpk.pub_key_attr = _DEFAULT_LPK_PUB;
+#endif
 	/* Turn privilege separation on by default */
 	if (use_privsep == -1)
 		use_privsep = PRIVSEP_NOSANDBOX;
@@ -424,6 +477,12 @@
 	sStreamLocalBindMask, sStreamLocalBindUnlink,
 	sAllowStreamLocalForwarding, sFingerprintHash,
 	sDeprecated, sUnsupported
+#ifdef WITH_LDAP_PUBKEY
+	,sLdapPublickey, sLdapServers, sLdapUserDN
+        ,sLdapGroupDN, sBindDN, sBindPw, sUIDAttribute, sMyGroup
+	,sLdapFilter, sForceTLS, sBindTimeout
+	,sSearchTimeout, sLdapConf ,sLpkPubKeyAttr 
+#endif
 } ServerOpCodes;
 
 #define SSHCFG_GLOBAL	0x01	/* allowed in main section of sshd_config */
@@ -536,6 +595,22 @@
 	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_GLOBAL },
 	{ "authorizedkeysfile", sAuthorizedKeysFile, SSHCFG_ALL },
 	{ "authorizedkeysfile2", sDeprecated, SSHCFG_ALL },
+#ifdef WITH_LDAP_PUBKEY
+	{ _DEFAULT_LPK_TOKEN, sLdapPublickey, SSHCFG_GLOBAL },
+	{ _DEFAULT_SRV_TOKEN, sLdapServers, SSHCFG_GLOBAL },
+	{ _DEFAULT_USR_TOKEN, sLdapUserDN, SSHCFG_GLOBAL },
+	{ _DEFAULT_GRP_TOKEN, sLdapGroupDN, SSHCFG_GLOBAL },
+        { _DEFAULT_UID_TOKEN, sUIDAttribute, SSHCFG_GLOBAL },
+	{ _DEFAULT_BDN_TOKEN, sBindDN, SSHCFG_GLOBAL },
+	{ _DEFAULT_BPW_TOKEN, sBindPw, SSHCFG_GLOBAL },
+	{ _DEFAULT_MYG_TOKEN, sMyGroup, SSHCFG_GLOBAL },
+	{ _DEFAULT_FIL_TOKEN, sLdapFilter, SSHCFG_GLOBAL },
+	{ _DEFAULT_TLS_TOKEN, sForceTLS, SSHCFG_GLOBAL },
+	{ _DEFAULT_BTI_TOKEN, sBindTimeout, SSHCFG_GLOBAL },
+	{ _DEFAULT_STI_TOKEN, sSearchTimeout, SSHCFG_GLOBAL },
+	{ _DEFAULT_LDP_TOKEN, sLdapConf, SSHCFG_GLOBAL },
+	{ "LpkPubKeyAttr", sLpkPubKeyAttr, SSHCFG_GLOBAL },
+#endif
 	{ "useprivilegeseparation", sUsePrivilegeSeparation, SSHCFG_GLOBAL},
 	{ "acceptenv", sAcceptEnv, SSHCFG_ALL },
 	{ "permittunnel", sPermitTunnel, SSHCFG_ALL },
@@ -959,6 +1034,7 @@
 	int cmdline = 0, *intptr, value, value2, n, port;
 	SyslogFacility *log_facility_ptr;
 	LogLevel *log_level_ptr;
+ 	unsigned long lvalue, *longptr;
 	ServerOpCodes opcode;
 	u_int i, flags = 0;
 	size_t len;
@@ -974,6 +1050,7 @@
 	if (!arg || !*arg || *arg == '#')
 		return 0;
 	intptr = NULL;
+	longptr = NULL;
 	charptr = NULL;
 	opcode = parse_token(arg, filename, linenum, &flags);
 
@@ -1856,6 +1933,133 @@
 		while (arg)
 		    arg = strdelim(&cp);
 		break;
+#ifdef WITH_LDAP_PUBKEY
+	case sLdapPublickey:
+		intptr = &options->lpk.on;
+		goto parse_flag;
+	case sLdapServers:
+		/* arg = strdelim(&cp); */
+		p = line;
+		while(*p++);
+		arg = p;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing ldap server",filename,linenum);
+		arg[strlen(arg)] = '\0';
+		if ((options->lpk.servers = ldap_parse_servers(arg)) == NULL)
+		    fatal("%s line %d: error in ldap servers", filename, linenum);
+		memset(arg,0,strlen(arg));
+		break;
+	case sLdapUserDN:
+		arg = cp;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing ldap server",filename,linenum);
+		arg[strlen(arg)] = '\0';
+		options->lpk.u_basedn = xstrdup(arg);
+		memset(arg,0,strlen(arg));
+		break;
+	case sLdapGroupDN:
+		arg = cp;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing ldap server",filename,linenum);
+		arg[strlen(arg)] = '\0';
+		options->lpk.g_basedn = xstrdup(arg);
+		memset(arg,0,strlen(arg));
+		break;
+	case sUIDAttribute:
+		arg = cp;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing uid_attr",filename,linenum);
+		arg[strlen(arg)] = '\0';
+		options->lpk.uid_attr = xstrdup(arg);
+		memset(arg,0,strlen(arg));
+		break;
+	case sBindDN:
+		arg = cp;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing binddn",filename,linenum);
+		arg[strlen(arg)] = '\0';
+		options->lpk.binddn = xstrdup(arg);
+		memset(arg,0,strlen(arg));
+		break;
+	case sBindPw:
+		arg = cp;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing bindpw",filename,linenum);
+		arg[strlen(arg)] = '\0';
+		options->lpk.bindpw = xstrdup(arg);
+		memset(arg,0,strlen(arg));
+		break;
+	case sMyGroup:
+		arg = cp;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing groupname",filename, linenum);
+		arg[strlen(arg)] = '\0';
+		options->lpk.sgroup = xstrdup(arg);
+		if (options->lpk.sgroup)
+		    options->lpk.fgroup = ldap_parse_groups(options->lpk.sgroup);
+		memset(arg,0,strlen(arg));
+		break;
+	case sLdapFilter:
+		arg = cp;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing filter",filename, linenum);
+		arg[strlen(arg)] = '\0';
+		options->lpk.filter = xstrdup(arg);
+		memset(arg,0,strlen(arg));
+		break;
+	case sForceTLS:
+		intptr = &options->lpk.tls;
+		arg = strdelim(&cp);
+		if (!arg || *arg == '\0')
+			fatal("%s line %d: missing yes/no argument.",
+			    filename, linenum);
+		value = 0;	/* silence compiler */
+		if (strcmp(arg, "yes") == 0)
+			value = 1;
+		else if (strcmp(arg, "no") == 0)
+			value = 0;
+		else if (strcmp(arg, "try") == 0)
+			value = -1;
+		else
+			fatal("%s line %d: Bad yes/no argument: %s",
+				filename, linenum, arg);
+		if (*intptr == -1)
+			*intptr = value;
+		break;
+	case sBindTimeout:
+		longptr = (unsigned long *) &options->lpk.b_timeout.tv_sec;
+parse_ulong:
+		arg = strdelim(&cp);
+		if (!arg || *arg == '\0')
+			fatal("%s line %d: missing integer value.",
+			    filename, linenum);
+		lvalue = atol(arg);
+		if (*activep && *longptr == -1)
+			*longptr = lvalue;
+		break;
+
+	case sSearchTimeout:
+		longptr = (unsigned long *) &options->lpk.s_timeout.tv_sec;
+		goto parse_ulong;
+		break;
+	case sLdapConf:
+		arg = cp;
+		if (!arg || *arg == '\0')
+		    fatal("%s line %d: missing LpkLdapConf", filename, linenum);
+		arg[strlen(arg)] = '\0';
+		options->lpk.l_conf = xstrdup(arg);
+		memset(arg, 0, strlen(arg));
+		break;
+	case sLpkPubKeyAttr:
+		arg = cp;
+                if (!arg || *arg == '\0')
+                    fatal("%s line %d: missing pubkeyattr",filename,linenum);
+                arg[strlen(arg)] = '\0';
+                options->lpk.pub_key_attr = xstrdup(arg);
+                memset(arg,0,strlen(arg));
+                break;
+
+#endif
 
 	default:
 		fatal("%s line %d: Missing handler for opcode %s (%d)",
diff -u openssh-7.1p2/servconf.h openssh-7.1p2-lpk/servconf.h
--- openssh-7.1p2/servconf.h	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/servconf.h	2016-02-24 16:25:03.000000000 -0800
@@ -16,6 +16,10 @@
 #ifndef SERVCONF_H
 #define SERVCONF_H
 
+#ifdef WITH_LDAP_PUBKEY
+#include "ldapauth.h"
+#endif
+
 #define MAX_PORTS		256	/* Max # ports. */
 
 #define MAX_ALLOW_USERS		256	/* Max # users on allow list. */
@@ -174,6 +178,9 @@
 	int	use_pam;		/* Enable auth via PAM */
 
 	int	permit_tun;
+#ifdef WITH_LDAP_PUBKEY
+        ldap_opt_t lpk;
+#endif
 
 	int	num_permitted_opens;
 
diff -u openssh-7.1p2/sshd.c openssh-7.1p2-lpk/sshd.c
--- openssh-7.1p2/sshd.c	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/sshd.c	2016-02-24 16:25:03.000000000 -0800
@@ -126,6 +126,10 @@
 #include "version.h"
 #include "ssherr.h"
 
+#ifdef WITH_LDAP_PUBKEY
+#include "ldapauth.h"
+#endif
+
 #ifndef O_NOCTTY
 #define O_NOCTTY	0
 #endif
@@ -1744,6 +1748,16 @@
 		exit(1);
 	}
 
+#ifdef WITH_LDAP_PUBKEY
+    /* ldap_options_print(&options.lpk); */
+    /* XXX initialize/check ldap connection and set *LD */
+    if (options.lpk.on) {
+        if (options.lpk.l_conf && (ldap_parse_lconf(&options.lpk) < 0) )
+            error("[LDAP] could not parse %s", options.lpk.l_conf);
+        if (ldap_connect(&options.lpk) < 0)
+            error("[LDAP] could not initialize ldap connection");
+    }
+#endif
 	debug("sshd version %s, %s", SSH_VERSION,
 #ifdef WITH_OPENSSL
 	    SSLeay_version(SSLEAY_VERSION)
diff -u openssh-7.1p2/sshd_config openssh-7.1p2-lpk/sshd_config
--- openssh-7.1p2/sshd_config	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/sshd_config	2016-02-24 16:25:03.000000000 -0800
@@ -122,6 +122,22 @@
 # no default banner path
 #Banner none
 
+# here are the new patched ldap related tokens
+# entries in your LDAP must have posixAccount & ldapPublicKey objectclass
+#UseLPK yes
+#LpkLdapConf /etc/ldap.conf
+#LpkServers  ldap://10.1.7.1/ ldap://10.1.7.2/
+#LpkUserDN   ou=users,dc=phear,dc=org
+#LpkGroupDN  ou=groups,dc=phear,dc=org
+#LpkBindDN cn=Manager,dc=phear,dc=org
+#LpkBindPw secret
+#LpkServerGroup mail
+#LpkFilter (hostAccess=master.phear.org)
+#LpkForceTLS no
+#LpkSearchTimelimit 3
+#LpkBindTimelimit 3
+#LpkPubKeyAttr sshPublicKey
+
 # override default of no subsystems
 Subsystem	sftp	/usr/libexec/sftp-server
 
diff -u openssh-7.1p2/sshd_config.5 openssh-7.1p2-lpk/sshd_config.5
--- openssh-7.1p2/sshd_config.5	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/sshd_config.5	2016-02-24 16:25:03.000000000 -0800
@@ -1670,6 +1670,62 @@
 to not use one.
 The default is
 .Pa /usr/X11R6/bin/xauth .
+.It Cm UseLPK
+Specifies whether LDAP public key retrieval must be used or not. It allow
+an easy centralisation of public keys within an LDAP directory. The argument must be
+.Dq yes
+or
+.Dq no .
+.It Cm LpkLdapConf
+Specifies whether LDAP Public keys should parse the specified ldap.conf file
+instead of sshd_config Tokens. The argument must be a valid path to an ldap.conf
+file like
+.Pa /etc/ldap.conf
+.It Cm LpkServers
+Specifies LDAP one or more [:space:] separated server's url the following form may be used:
+.Pp
+LpkServers ldaps://127.0.0.1 ldap://127.0.0.2 ldap://127.0.0.3
+.It Cm LpkUserDN
+Specifies the LDAP user DN.
+.Pp
+LpkUserDN ou=users,dc=phear,dc=org
+.It Cm LpkGroupDN
+Specifies the LDAP groups DN.
+.Pp
+LpkGroupDN ou=groups,dc=phear,dc=org
+.It Cm LpkBindDN
+Specifies the LDAP bind DN to use if necessary.
+.Pp
+LpkBindDN cn=Manager,dc=phear,dc=org
+.It Cm LpkBindPw
+Specifies the LDAP bind credential. 
+.Pp
+LpkBindPw secret
+.It Cm LpkServerGroup
+Specifies one or more [:space:] separated group the server is part of. 
+.Pp
+LpkServerGroup unix mail prod
+.It Cm LpkFilter
+Specifies an additional LDAP filter to use for finding SSH keys
+.Pp
+LpkFilter (hostAccess=master.phear.org)
+.It Cm LpkForceTLS
+Specifies if the LDAP server connection must be tried, forced or not used. The argument must be 
+.Dq yes
+or
+.Dq no
+or
+.Dq try .
+.It Cm LpkSearchTimelimit
+Sepcifies the search time limit before the search is considered over. value is
+in seconds.
+.Pp
+LpkSearchTimelimit 3
+.It Cm LpkBindTimelimit
+Sepcifies the bind time limit before the connection is considered dead. value is
+in seconds.
+.Pp
+LpkBindTimelimit 3
 .El
 .Sh TIME FORMATS
 .Xr sshd 8
diff -u openssh-7.1p2/version.h openssh-7.1p2-lpk/version.h
--- openssh-7.1p2/version.h	2016-01-13 17:10:45.000000000 -0800
+++ openssh-7.1p2-lpk/version.h	2016-02-24 16:47:50.000000000 -0800
@@ -3,4 +3,6 @@
 #define SSH_VERSION	"OpenSSH_7.1"
 
 #define SSH_PORTABLE	"p2"
+#define SSH_LPK		"lpk"
+#define SSH_RELEASE_MINIMUM	SSH_VERSION SSH_PORTABLE SSH_LPK
 #define SSH_RELEASE	SSH_VERSION SSH_PORTABLE
