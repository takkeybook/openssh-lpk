This is a forward-port of the OpenSSH LPK support patch.

It adds support for storing OpenSSH public keys in LDAP. It also supports
grouping of machines in the LDAP data to limit users to specific machines.

The latest homepage for the LPK project is:
http://code.google.com/p/openssh-lpk/

Signed-off-by: Tim Harder <radhermit@gentoo.org>

Change history:
===============
2016/02/28
contrib-openssh-lpk-7.2p1-0.3.14.patch:
---------------------------------------
Rediff for openssh-7.2p1.
Ported-from: contrib-openssh-lpk-6.6p1-0.3.14.patch
Ported-by: Takashi Kagimoto <takashi.kagimoto@drecom.co.jp>

2014/06/27
contrib-openssh-lpk-6.6p1-0.3.14.patch:
---------------------------------------
Rediff for openssh-6.6p1.
Ported-from: contrib-openssh-lpk-5.9p1-0.3.14.patch
Ported-by: Takashi Kagimoto <takashi.kagimoto@drecom.co.jp>

2013/11/04
contrib-openssh-lpk-6.3p1-0.3.14.patch:
---------------------------------------
Rediff for openssh-6.3p1.
Ported-from: contrib-openssh-lpk-5.9p1-0.3.14.patch

2013/06/12
contrib-openssh-lpk-6.2p2-0.3.14.patch:
---------------------------------------
Rediff for openssh-6.2p2.
Ported-from: contrib-openssh-lpk-5.9p1-0.3.14.patch

2012/04/30
contrib-openssh-lpk-6.0p1-0.3.14.patch:
---------------------------------------
Rediff for openssh-6.0p1.
Ported-from: contrib-openssh-lpk-5.9p1-0.3.14.patch

2011/09/07
contrib-openssh-lpk-5.9p1-0.3.14.patch:
---------------------------------------
Rediff for openssh-5.9p1.
Ported-from: contrib-openssh-lpk-5.8p1-0.3.14.patch

2011/05/15
contrib-openssh-lpk-5.8p1-0.3.14.patch:
---------------------------------------
Added uid attribute patch from aravind@freeshell.org.
Developed and used internally at Mozilla.

2011/05/15
contrib-openssh-lpk-5.8p1-0.3.13.patch:
---------------------------------------
Rediff for openssh-5.8p2. Customized the version.h fragment to apply without
rejects when the version is bumped in future.
Ported-from: contrib-openssh-lpk-5.6p1-0.3.13.patch

2010/08/25
contrib-openssh-lpk-5.6p1-0.3.13.patch:
---------------------------------------
Rediff for openssh-5.6p1 (no rediff was required for 5.5p1).
Ported-from: contrib-openssh-lpk-5.4p1-0.3.13.patch

2010/03/27
contrib-openssh-lpk-5.4p1-0.3.13.patch:
---------------------------------------
Integrate openssh-lpk-0.3.10_5.4p1-64bit.patchfrom upstream repo r25.
- Uses ulong for handling timeouts on 64-bit better.
Ported-from: contrib-openssh-lpk-5.4p1-0.3.12.patch

2010/03/27
contrib-openssh-lpk-5.4p1-0.3.12.patch:
---------------------------------------
Integrate openssh-5.3p1+lpk+pubkeyattrib.patch from upstream repo (originally
from Julian.Zeiss@fiducia.de).
- Adds new config option LpkPubKeyAttr for the name of the key attribute (still
  sshPublicKey by default).
- Includes LPK suffix in version string.
Ported-from: contrib-openssh-lpk-5.4p1-0.3.11.patch

2010/03/27
contrib-openssh-lpk-5.4p1-0.3.11.patch:
---------------------------------------
Rename to match new upstream scheme.
Rediff for openssh-5.4p1.
Ported-from: openssh-lpk-5.3p1-0.3.11.patch

2009/10/09:
openssh-lpk-5.3p1-0.3.11.patch:
-------------------------------
Ported-from: openssh-lpk-5.2p1-0.3.11.patch
Rediff for openssh-5.3p1.

2009/02/24:
openssh-lpk-5.2p1-0.3.11.patch:
-------------------------------
Ported-from: openssh-lpk-5.2p1-0.3.10.patch
Moved the servconf.c initialize_server_options block to make additional patching easier.

2009/02/24:
openssh-lpk-5.2p1-0.3.10.patch:
-------------------------------
Ported-from: openssh-lpk-5.1p1-0.3.10.patch
Rediff for openssh-5.2p1.

2008/08/23:
openssh-lpk-5.1p1-0.3.10.patch:
-------------------------------
Ported-from: openssh-lpk-5.1p1-0.3.9.patch
The 0.3.10 version of the patch includes a fix for 64-bit platforms, as
discovered by Gentoo, where the bind timeout and search timeout values were not
being parsed correctly: http://bugs.gentoo.org/210110

2008/08/23:
openssh-lpk-5.1p1-0.3.9.patch:
------------------------------
Ported-from: openssh-lpk-4.6p1-0.3.9.patch
Rediff for openssh-5.1p1

--- openssh-7.2p1/Makefile.in.orig	2016-02-28 12:41:54.343332722 +0900
+++ openssh-7.2p1/Makefile.in	2016-02-28 13:15:19.592637301 +0900
@@ -110,7 +110,7 @@
 	sftp-server.o sftp-common.o \
 	sandbox-null.o sandbox-rlimit.o sandbox-systrace.o sandbox-darwin.o \
 	sandbox-seccomp-filter.o sandbox-capsicum.o sandbox-pledge.o \
-	sandbox-solaris.o
+	sandbox-solaris.o ldapauth.o
 
 MANPAGES	= moduli.5.out scp.1.out ssh-add.1.out ssh-agent.1.out ssh-keygen.1.out ssh-keyscan.1.out ssh.1.out sshd.8.out sftp-server.8.out sftp.1.out ssh-keysign.8.out ssh-pkcs11-helper.8.out sshd_config.5.out ssh_config.5.out
 MANPAGES_IN	= moduli.5 scp.1 ssh-add.1 ssh-agent.1 ssh-keygen.1 ssh-keyscan.1 ssh.1 sshd.8 sftp-server.8 sftp.1 ssh-keysign.8 ssh-pkcs11-helper.8 sshd_config.5 ssh_config.5
--- openssh-7.2p1/README.lpk.orig	2016-02-28 13:38:19.930945955 +0900
+++ openssh-7.2p1/README.lpk	2016-02-28 13:18:32.148292867 +0900
@@ -0,0 +1,267 @@
+OpenSSH LDAP PUBLIC KEY PATCH
+Copyright (c) 2003 Eric AUGE (eau@phear.org)
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+purposes of this patch:
+
+This patch would help to have authentication centralization policy
+using ssh public key authentication.
+This patch could be an alternative to other "secure" authentication system
+working in a similar way (Kerberos, SecurID, etc...), except the fact
+that it's based on OpenSSH and its public key abilities.
+
+>> FYI: <<
+'uid': means unix accounts existing on the current server
+'lpkServerGroup:' mean server group configured on the current server ('lpkServerGroup' in sshd_config)
+
+example schema:
+
+
+                                  server1 (uid: eau,rival,toto) (lpkServerGroup: unix)
+                ___________      /
+               /           \ --- - server3 (uid: eau, titi) (lpkServerGroup: unix)
+              | LDAP Server |    \
+             | eau  ,rival |     server2 (uid: rival, eau) (lpkServerGroup: unix)
+             | titi ,toto  |
+             | userx,....  |         server5 (uid: eau)  (lpkServerGroup: mail)
+               \___________/ \       /
+                              ----- - server4 (uid: eau, rival)  (no group configured)
+                                    \
+                                       etc...
+
+- WHAT WE NEED :
+
+  * configured LDAP server somewhere on the network (i.e. OpenLDAP)
+  * patched sshd (with this patch ;)
+  * LDAP user(/group) entry (look at users.ldif (& groups.ldif)):
+        User entry:
+       - attached to the 'ldapPublicKey' objectclass
+       - attached to the 'posixAccount' objectclass
+       - with a filled 'sshPublicKey' attribute
+       Example:
+               dn: uid=eau,ou=users,dc=cuckoos,dc=net
+               objectclass: top
+               objectclass: person
+               objectclass: organizationalPerson
+               objectclass: posixAccount
+               objectclass: ldapPublicKey
+               description: Eric AUGE Account
+               userPassword: blah
+               cn: Eric AUGE
+               sn: Eric AUGE
+               uid: eau
+               uidNumber: 1034
+               gidNumber: 1
+               homeDirectory: /export/home/eau
+               sshPublicKey: ssh-dss AAAAB3...
+               sshPublicKey: ssh-dss AAAAM5...
+
+       Group entry:
+       - attached to the 'posixGroup' objectclass
+       - with a 'cn' groupname attribute
+       - with multiple 'memberUid' attributes filled with usernames allowed in this group
+       Example:
+               # few members
+               dn: cn=unix,ou=groups,dc=cuckoos,dc=net
+               objectclass: top
+               objectclass: posixGroup
+               description: Unix based servers group
+               cn: unix
+               gidNumber: 1002
+               memberUid: eau
+               memberUid: user1
+               memberUid: user2
+
+
+- HOW IT WORKS :
+
+  * without patch
+  If a user wants to authenticate to log in a server the sshd, will first look for authentication method allowed (RSAauth,kerberos,etc..)
+  and if RSAauth and tickets based auth fails, it will fallback to standard password authentication (if enabled).
+
+  * with the patch
+  If a user want to authenticate to log in a server, the sshd will first look for auth method including LDAP pubkey, if the ldappubkey options is enabled.
+  It will do an ldapsearch to get the public key directly from the LDAP instead of reading it from the server filesystem.
+  (usually in $HOME/.ssh/authorized_keys)
+
+  If groups are enabled, it will also check if the user that wants to login is in the group of the server he is trying to log into.
+  If it fails, it falls back on RSA auth files ($HOME/.ssh/authorized_keys), etc.. and finally to standard password authentication (if enabled).
+
+  7 tokens are added to sshd_config :
+  # here is the new patched ldap related tokens
+  # entries in your LDAP must be posixAccount & strongAuthenticationUser & posixGroup
+  UseLPK yes                                                           # look the pub key into LDAP
+  LpkServers ldap://10.31.32.5/ ldap://10.31.32.4 ldap://10.31.32.3    # which LDAP server for users ? (URL format)
+  LpkUserDN  ou=users,dc=foobar,dc=net                                 # which base DN for users ?
+  LpkGroupDN ou=groups,dc=foobar,dc=net                                        # which base DN for groups ?
+  LpkBindDN cn=manager,dc=foobar,dc=net                                        # which bind DN ?
+  LpkBindPw asecret                                                    # bind DN credidentials
+  LpkServerGroup agroupname                                            # the group the server is part of
+
+  Right now i'm using anonymous binding to get public keys, because getting public keys of someone doesn't impersonate him<B8> but there is some
+  flaws you have to take care of.
+
+- HOW TO INSERT A USER/KEY INTO AN LDAP ENTRY
+
+  * my way (there is plenty :)
+  - create ldif file (i.e. users.ldif)
+  - cat ~/.ssh/id_dsa.pub OR cat ~/.ssh/id_rsa.pub OR cat ~/.ssh/identity.pub
+  - my way in 4 steps :
+  Example:
+
+  # you add this to the user entry in the LDIF file :
+  [...]
+  objectclass: posixAccount
+  objectclass: ldapPublicKey
+  [...]
+  sshPubliKey: ssh-dss AAAABDh12DDUR2...
+  [...]
+
+  # insert your entry and you're done :)
+  ldapadd -D balblabla -w bleh < file.ldif
+
+  all standard options can be present in the 'sshPublicKey' attribute.
+
+- WHY :
+
+  Simply because, i was looking for a way to centralize all sysadmins authentication, easily,  without completely using LDAP
+  as authentication method (like pam_ldap etc..).
+
+  After looking into Kerberos, SecurID, and other centralized secure authentications systems, the use of RSA and LDAP to get
+  public key for authentication allows us to control who has access to which server (the user needs an account and to be in 'strongAuthenticationUser'
+  objectclass within LDAP and part of the group the SSH server is in).
+
+  Passwords update are no longer a nightmare for a server farm (key pair passphrase is stored on each user's box and private key is locally encrypted using his passphrase
+  so each user can change it as much as he wants).
+
+  Blocking a user account can be done directly from the LDAP (if sshd is using RSAAuth + ldap only).
+
+- RULES :
+  Entry in the LDAP server must respect 'posixAccount' and 'ldapPublicKey' which are defined in core.schema.
+  and the additionnal lpk.schema.
+
+  This patch could allow a smooth transition between standard auth (/etc/passwd) and complete LDAP based authentication
+  (pamldap, nss_ldap, etc..).
+
+  This can be an alternative to other (old?/expensive?) authentication methods (Kerberos/SecurID/..).
+
+  Referring to schema at the beginning of this file if user 'eau' is only in group 'unix'
+  'eau' would ONLY access 'server1', 'server2', 'server3' AND 'server4' BUT NOT 'server5'.
+  If you then modify the LDAP 'mail' group entry to add 'memberUid: eau' THEN user 'eau' would be able
+  to log in 'server5' (i hope you got the idea, my english is bad :).
+
+  Each server's sshd is patched and configured to ask the public key and the group infos in the LDAP
+  server.
+  When you want to allow a new user to have access to the server parc, you just add him an account on
+  your servers, you add his public key into his entry on the LDAP server, it's done.
+
+  Because sshds are looking public keys into the LDAP directly instead of a file ($HOME/.ssh/authorized_keys).
+
+  When the user needs to change his passphrase he can do it directly from his workstation by changing
+  his own key set lock passphrase, and all servers are automatically aware.
+
+  With a CAREFUL LDAP server configuration you could allow a user to add/delete/modify his own entry himself
+  so he can add/modify/delete himself his public key when needed.
+
+<AD> FLAWS :
+  LDAP must be well configured, getting the public key of some user is not a problem, but if anonymous LDAP
+  allow write to users dn, somebody could replace someuser's public key by its own and impersonate some
+  of your users in all your server farm be VERY CAREFUL.
+
+  MITM attack when sshd is requesting the public key, could lead to a compromise of your servers allowing login
+  as the impersonnated user.
+
+  If LDAP server is down then, fallback on passwd auth.
+
+  the ldap code part has not been well audited yet.
+
+- LDAP USER ENTRY EXAMPLES (LDIF Format, look in users.ldif)
+    --- CUT HERE ---
+    dn: uid=jdoe,ou=users,dc=foobar,dc=net
+    objectclass: top
+    objectclass: person
+    objectclass: organizationalPerson
+    objectclass: posixAccount
+    objectclass: ldapPublicKey
+    description: My account
+    cn: John Doe
+    sn: John Doe
+    uid: jdoe
+    uidNumber: 100
+    gidNumber: 100
+    homeDirectory: /home/jdoe
+    sshPublicKey: ssh-dss AAAAB3NzaC1kc3MAAAEBAOvL8pREUg9wSy/8+hQJ54YF3AXkB0OZrXB....
+    [...]
+    --- CUT HERE ---
+
+- LDAP GROUP ENTRY EXAMPLES (LDIF Format, look in groups.ldif)
+    --- CUT HERE ---
+    dn: cn=unix,ou=groups,dc=cuckoos,dc=net
+    objectclass: top
+    objectclass: posixGroup
+    description: Unix based servers group
+    cn: unix
+    gidNumber: 1002
+    memberUid: jdoe
+    memberUid: user1
+    memberUid: user2
+    [...]
+    --- CUT HERE ---
+
+>> FYI: <<
+Multiple 'sshPublicKey' in a user entry are allowed, as well as multiple 'memberUid' attributes in a group entry
+
+- COMPILING:
+  1. Apply the patch
+  2. ./configure --with-your-options --with-ldap=/prefix/to/ldap_libs_and_includes
+  3. make
+  4. it's done.
+
+- BLA :
+  I hope this could help, and i hope to be clear enough,, or give ideas.  questions/comments/improvements are welcome.
+
+- TODO :
+  Redesign differently.
+
+- DOCS/LINK :
+  http://pacsec.jp/core05/psj05-barisani-en.pdf
+  http://fritz.potsdam.edu/projects/openssh-lpk/
+  http://fritz.potsdam.edu/projects/sshgate/
+  http://dev.inversepath.com/trac/openssh-lpk
+  http://lam.sf.net/ ( http://lam.sourceforge.net/documentation/supportedSchemas.htm )
+
+- CONTRIBUTORS/IDEAS/GREETS :
+  - Falk Siemonsmeier.
+  - Jacob Rief.
+  - Michael Durchgraf.
+  - frederic peters.
+  - Finlay dobbie.
+  - Stefan Fisher.
+  - Robin H. Johnson.
+  - Adrian Bridgett.
+
+- CONTACT :
+  - Eric AUGE <eau@phear.org>
+  - Andrea Barisani <andrea@inversepath.com>
--- openssh-7.2p1/auth-rsa.c.orig	2016-02-28 12:41:54.347332719 +0900
+++ openssh-7.2p1/auth-rsa.c	2016-02-28 12:57:46.190410662 +0900
@@ -176,6 +176,93 @@
 	FILE *f;
 	u_long linenum = 0;
 	Key *key;
+#ifdef WITH_LDAP_PUBKEY
+       ldap_key_t * k;
+       unsigned int i = 0;
+#endif
+
+#ifdef WITH_LDAP_PUBKEY
+       /* here is the job */
+       key = key_new(KEY_RSA1);
+
+       if (options.lpk.on) {
+           debug("[LDAP] trying LDAP first uid=%s", pw->pw_name);
+           if ( ldap_ismember(&options.lpk, pw->pw_name) > 0) {
+               if ( (k = ldap_getuserkey(&options.lpk, pw->pw_name)) != NULL) {
+                   for (i = 0 ; i < k->num ; i++) {
+                       char *cp, *options = NULL;
+
+                       for (cp = k->keys[i]->bv_val; *cp == ' ' || *cp == '\t'; cp++)
+                           ;
+                       if (!*cp || *cp == '\n' || *cp == '#')
+                           continue;
+
+                       /*
+                       * Check if there are options for this key, and if so,
+                       * save their starting address and skip the option part
+                       * for now.  If there are no options, set the starting
+                       * address to NULL.
+                        */
+                       if (*cp < '0' || *cp > '9') {
+                           int quoted = 0;
+                           options = cp;
+                           for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
+                               if (*cp == '\\' && cp[1] == '"')
+                                   cp++;       /* Skip both */
+                               else if (*cp == '"')
+                                   quoted = !quoted;
+                           }
+                       } else
+                           options = NULL;
+
+                       /* Parse the key from the line. */
+                       if (hostfile_read_key(&cp, &bits, key) == 0) {
+                           debug("[LDAP] line %d: non ssh1 key syntax", i);
+                           continue;
+                       }
+                       /* cp now points to the comment part. */
+
+                       /* Check if the we have found the desired key (identified by its modulus). */
+                       if (BN_cmp(key->rsa->n, client_n) != 0)
+                           continue;
+
+                       /* check the real bits  */
+                       if (bits != (unsigned int)BN_num_bits(key->rsa->n))
+                           logit("[LDAP] Warning: ldap, line %lu: keysize mismatch: "
+                                   "actual %d vs. announced %d.", (unsigned long)i, BN_num_bits(key->rsa->n), bits);
+
+                       /* We have found the desired key. */
+                       /*
+                       * If our options do not allow this key to be used,
+                       * do not send challenge.
+                        */
+                       if (!auth_parse_options(pw, options, "[LDAP]", (unsigned long) i))
+                           continue;
+
+                       /* break out, this key is allowed */
+                       allowed = 1;
+
+                       /* add the return stuff etc... */
+                       /* Restore the privileged uid. */
+                       restore_uid();
+
+                       /* return key if allowed */
+                       if (allowed && rkey != NULL)
+                           *rkey = key;
+                       else
+                           key_free(key);
+
+                       ldap_keys_free(k);
+                       return (allowed);
+                   }
+               } else {
+                   logit("[LDAP] no keys found for '%s'!", pw->pw_name);
+               }
+           } else {
+               logit("[LDAP] '%s' is not in '%s'", pw->pw_name, options.lpk.sgroup);
+           }
+       }
+#endif
 
 	debug("trying public RSA key file %s", file);
 	if ((f = auth_openkeyfile(file, pw, options.strict_modes)) == NULL)
--- openssh-7.2p1/auth2-pubkey.c.orig	2016-02-28 12:41:54.351332715 +0900
+++ openssh-7.2p1/auth2-pubkey.c	2016-02-28 17:50:22.878266508 +0900
@@ -69,6 +69,10 @@
 #include "channels.h" /* XXX for session.h */
 #include "session.h" /* XXX for child_set_env(); refactor? */
 
+#ifdef WITH_LDAP_PUBKEY
+#include "ldapauth.h"
+#endif
+
 /* import */
 extern ServerOptions options;
 extern u_char *session_id2;
@@ -917,6 +921,91 @@
 	return found_key;
 }
 
+#ifdef WITH_LDAP_PUBKEY
+/*
+ * Checks whether key is allowed in ldap.
+ * returns 1 if the key is allowed or 0 otherwise.
+ */
+static int
+user_key_ldap_allowed2(struct passwd *pw, Key *key)
+{
+       int found_key = 0;
+       u_long linenum = 0;
+       Key *found = NULL;
+       ldap_key_t * k = NULL;
+       unsigned int i = 0;
+       char *fp = NULL;
+       char file[9] = "LDAP key";
+
+       /* Temporarily use the user's uid. */
+       temporarily_use_uid(pw);
+
+       /* allocate a new key type */
+       found = key_new(key->type);
+
+       debug("[LDAP] trying LDAP first uid=%s",pw->pw_name);
+       if (ldap_ismember(&options.lpk, pw->pw_name) > 0) {
+               if ((k = ldap_getuserkey(&options.lpk, pw->pw_name)) != NULL) {
+                       /* Skip leading whitespace, empty and comment lines. */
+                       for (i = 0 ; i < k->num ; i++) {
+                               /* dont forget if multiple keys to reset options */
+                               char *cp, *key_options = NULL;
+
+                               for (cp = (char *)k->keys[i]->bv_val; *cp == ' ' || *cp == '\t'; cp++)
+                                       ;
+                               if (!*cp || *cp == '\n' || *cp == '#')
+                                       continue;
+
+                               if (key_read(found, &cp) != 1) {
+                                       /* no key?  check if there are options for this key */
+                                       int quoted = 0;
+                                       debug2("[LDAP] user_key_allowed: check options: '%s'", cp);
+                                       key_options = cp;
+                                       for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
+                                               if (*cp == '\\' && cp[1] == '"')
+                                                       cp++;   /* Skip both */
+                                               else if (*cp == '"')
+                                                       quoted = !quoted;
+                                       }
+                                       /* Skip remaining whitespace. */
+                                       for (; *cp == ' ' || *cp == '\t'; cp++)
+                                               ;
+                                       if (key_read(found, &cp) != 1) {
+                                               debug2("[LDAP] user_key_allowed: advance: '%s'", cp);
+                                               /* still no key?  advance to next line*/
+                                               continue;
+                                       }
+                               }
+
+                               if (key_equal(found, key) &&
+                                       auth_parse_options(pw, key_options, file, linenum) == 1) {
+                                       found_key = 1;
+                                       debug("[LDAP] matching key found");
+                                       fp = sshkey_fingerprint(found, options.fingerprint_hash, SSH_FP_DEFAULT);
+                                       verbose("[LDAP] Found matching %s key: %s", key_type(found), fp);
+                                       goto done;
+                               }
+                       }/* end of LDAP for() */
+               } else {
+                       logit("[LDAP] no keys found for '%s'!", pw->pw_name);
+               }
+       } else {
+       logit("[LDAP] '%s' is not in '%s'", pw->pw_name, options.lpk.sgroup);
+       }
+
+done:
+       /* restoring memory */
+       if (k != NULL)
+               ldap_keys_free(k);
+       if (fp != NULL)
+               free(fp);
+       if (found != NULL)
+               key_free(found);
+       restore_uid();
+       return found_key;
+}
+#endif
+ 
 /*
  * Checks whether key is allowed in output of command.
  * returns 1 if the key is allowed or 0 otherwise.
@@ -1060,6 +1149,14 @@
 	if (success > 0)
 		return success;
 
+#ifdef WITH_LDAP_PUBKEY
+       if (options.lpk.on) {
+               success = user_key_ldap_allowed2(pw, key);
+               if (success)
+                       return success;
+       }
+#endif
+
 	for (i = 0; !success && i < options.num_authkeys_files; i++) {
 
 		if (strcasecmp(options.authorized_keys_files[i], "none") == 0)
--- openssh-7.2p1/configure.ac.orig	2016-02-28 12:41:54.000000000 +0900
+++ openssh-7.2p1/configure.ac	2016-02-28 13:08:07.917430739 +0900
@@ -1646,6 +1646,37 @@
 	fi
 fi
 
+# Check whether user wants LDAP support
+LDAP_MSG="no"
+AC_ARG_WITH(ldap,
+       [  --with-ldap[[=PATH]]      Enable LDAP pubkey support (optionally in PATH)],
+       [
+               if test "x$withval" != "xno" ; then
+
+                       if test "x$withval" != "xyes" ; then
+                               CPPFLAGS="$CPPFLAGS -I${withval}/include"
+                               LDFLAGS="$LDFLAGS -L${withval}/lib"
+                       fi
+
+                       AC_DEFINE([WITH_LDAP_PUBKEY], 1, [Enable LDAP pubkey support])
+                       LIBS="-lldap $LIBS"
+                       LDAP_MSG="yes"
+
+                       AC_MSG_CHECKING([for LDAP support])
+                       AC_TRY_COMPILE(
+                               [#include <sys/types.h>
+                                #include <ldap.h>],
+                               [(void)ldap_init(0, 0);],
+                               [AC_MSG_RESULT(yes)],
+                               [
+                                   AC_MSG_RESULT(no)
+                                       AC_MSG_ERROR([** Incomplete or missing ldap libraries **])
+                               ]
+               )
+               fi
+       ]
+)
+
 dnl    Checks for library functions. Please keep in alphabetical order
 AC_CHECK_FUNCS([ \
 	Blowfish_initstate \
@@ -4979,6 +5010,7 @@
 echo "                   SELinux support: $SELINUX_MSG"
 echo "                 Smartcard support: $SCARD_MSG"
 echo "                     S/KEY support: $SKEY_MSG"
+echo "                      LDAP support: $LDAP_MSG"
 echo "              MD5 password support: $MD5_MSG"
 echo "                   libedit support: $LIBEDIT_MSG"
 echo "  Solaris process contract support: $SPC_MSG"
--- openssh-7.2p1/lpk-user-example.txt.orig	2016-02-28 13:38:35.450925529 +0900
+++ openssh-7.2p1/lpk-user-example.txt	2016-02-28 13:14:13.752754614 +0900
@@ -0,0 +1,117 @@
+
+Post to ML -> User Made Quick Install Doc.
+Contribution from John Lane <john@lane.uk.net>
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+OpenSSH LDAP keystore Patch
+===========================
+
+NOTE: these notes are a transcript of a specific installation
+      they work for me, your specifics may be different!
+      from John Lane March 17th 2005         john@lane.uk.net
+
+This is a patch to OpenSSH 4.0p1 to allow it to obtain users' public keys
+from their LDAP record as an alternative to ~/.ssh/authorized_keys.
+
+(Assuming here that necessary build stuff is in $BUILD)
+
+cd $BUILD/openssh-4.0p1
+patch -Np1 -i $BUILD/openssh-lpk-4.0p1-0.3.patch
+mkdir -p /var/empty &&
+./configure --prefix=/usr --sysconfdir=/etc/ssh \
+    --libexecdir=/usr/sbin --with-md5-passwords --with-pam \
+    --with-libs="-lldap" --with-cppflags="-DWITH_LDAP_PUBKEY"
+Now do.
+make &&
+make install
+
+Add the following config to /etc/ssh/ssh_config
+UseLPK yes
+LpkServers ldap://myhost.mydomain.com
+LpkUserDN  ou=People,dc=mydomain,dc=com
+
+We need to tell sshd about the SSL keys during boot, as root's
+environment does not exist at that time. Edit /etc/rc.d/init.d/sshd.
+Change the startup code from this:
+                echo "Starting SSH Server..."
+                loadproc /usr/sbin/sshd
+                ;;
+to this:
+                echo "Starting SSH Server..."
+                LDAPRC="/root/.ldaprc" loadproc /usr/sbin/sshd
+                ;;
+
+Re-start the sshd daemon:
+/etc/rc.d/init.d/sshd restart
+
+Install the additional LDAP schema
+cp $BUILD/openssh-lpk-0.2.schema  /etc/openldap/schema/openssh.schema
+
+Now add the openSSH LDAP schema to /etc/openldap/slapd.conf:
+Add the following to the end of the existing block of schema includes
+include         /etc/openldap/schema/openssh.schema
+
+Re-start the LDAP server:
+/etc/rc.d/init.d/slapd restart
+
+To add one or more public keys to a user, eg "testuser" :
+ldapsearch -x -W -Z -LLL -b "uid=testuser,ou=People,dc=mydomain,dc=com" -D
+"uid=testuser,ou=People,dc=mydomain,dc=com" > /tmp/testuser
+
+append the following to this /tmp/testuser file
+objectclass: ldapPublicKey
+sshPublicKey: ssh-rsa
+AAAAB3NzaC1yc2EAAAABJQAAAIB3dsrwqXqD7E4zYYrxwdDKBUQxKMioXy9pxFVai64kAPxjU9KS
+qIo7QfkjslfsjflksjfldfkjsldfjLX/5zkzRmT28I5piGzunPv17S89z8XwSsuAoR1t86t+5dlI
+7eZE/gVbn2UQkQq7+kdDTS2yXV6VnC52N/kKLG3ciBkBAw== General Purpose RSA Key
+
+Then do a modify:
+ldapmodify -x -D "uid=testuser,ou=People,dc=mydomain,dc=com" -W -f
+/tmp/testuser -Z
+Enter LDAP Password:
+modifying entry "uid=testuser,ou=People,dc=mydomain,dc=com"
+And check the modify is ok:
+ldapsearch -x -W -Z -b "uid=testuser,ou=People,dc=mydomain,dc=com" -D
+"uid=testuser,ou=People,dc=mydomain,dc=com"
+Enter LDAP Password:
+# extended LDIF
+#
+# LDAPv3
+# base <uid=testuser,ou=People,dc=mydomain,dc=com> with scope sub
+# filter: (objectclass=*)
+# requesting: ALL
+#
+
+# testuser, People, mydomain.com
+dn: uid=testuser,ou=People,dc=mydomain,dc=com
+uid: testuser
+cn: testuser
+objectClass: account
+objectClass: posixAccount
+objectClass: top
+objectClass: shadowAccount
+objectClass: ldapPublicKey
+shadowLastChange: 12757
+shadowMax: 99999
+shadowWarning: 7
+loginShell: /bin/bash
+uidNumber: 9999
+gidNumber: 501
+homeDirectory: /home/testuser
+userPassword:: e1NTSEF9UDgwV1hnM1VjUDRJK0k1YnFiL1d4ZUJObXlZZ3Z3UTU=
+sshPublicKey: ssh-rsa
+AAAAB3NzaC1yc2EAAAABJQAAAIB3dsrwqXqD7E4zYYrxwdDKBUQxKMioXy9pxFVai64kAPxjU9KSqIo7QfkjslfsjflksjfldfkjsldfjLX/5zkzRmT28I5piGzunPv17S89z
+8XwSsuAoR1t86t+5dlI7eZE/gVbn2UQkQq7+kdDTS2yXV6VnC52N/kKLG3ciBkBAw== General Purpose RSA Key
+
+# search result
+search: 3
+result: 0 Success
+
+# numResponses: 2
+# numEntries: 1
+
+Now start a ssh session to user "testuser" from usual ssh client (e.g.
+puTTY). Login should succeed.
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
--- openssh-7.2p1/openssh-lpk_openldap.schema.orig	2016-02-28 13:38:12.754956577 +0900
+++ openssh-7.2p1/openssh-lpk_openldap.schema	2016-02-28 13:16:34.872501462 +0900
@@ -0,0 +1,19 @@
+#
+# LDAP Public Key Patch schema for use with openssh-ldappubkey
+# Author: Eric AUGE <eau@phear.org>
+#
+# Based on the proposal of : Mark Ruijter
+#
+
+
+# octetString SYNTAX
+attributetype ( 1.3.6.1.4.1.24552.500.1.1.1.13 NAME 'sshPublicKey'
+       DESC 'MANDATORY: OpenSSH Public key'
+       EQUALITY octetStringMatch
+       SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )
+
+# printableString SYNTAX yes|no
+objectclass ( 1.3.6.1.4.1.24552.500.1.1.2.0 NAME 'ldapPublicKey' SUP top AUXILIARY
+       DESC 'MANDATORY: OpenSSH LPK objectclass'
+       MUST ( sshPublicKey $ uid )
+       )
--- openssh-7.2p1/openssh-lpk_sun.schema.orig	2016-02-28 13:38:06.282964067 +0900
+++ openssh-7.2p1/openssh-lpk_sun.schema	2016-02-28 13:16:59.640457680 +0900
@@ -0,0 +1,21 @@
+#
+# LDAP Public Key Patch schema for use with openssh-ldappubkey
+# Author: Eric AUGE <eau@phear.org>
+#
+# Schema for Sun Directory Server.
+# Based on the original schema, modified by Stefan Fischer.
+#
+
+dn: cn=schema
+
+# octetString SYNTAX
+attributeTypes: ( 1.3.6.1.4.1.24552.500.1.1.1.13 NAME 'sshPublicKey'
+       DESC 'MANDATORY: OpenSSH Public key'
+       EQUALITY octetStringMatch
+       SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )
+
+# printableString SYNTAX yes|no
+objectClasses: ( 1.3.6.1.4.1.24552.500.1.1.2.0 NAME 'ldapPublicKey' SUP top AUXILIARY
+       DESC 'MANDATORY: OpenSSH LPK objectclass'
+       MUST ( sshPublicKey $ uid )
+       )
--- openssh-7.2p1/servconf.c.orig	2016-02-28 12:41:54.415332648 +0900
+++ openssh-7.2p1/servconf.c	2016-02-28 13:28:18.531626467 +0900
@@ -58,6 +58,10 @@
 #include "myproposal.h"
 #include "digest.h"
 
+#ifdef WITH_LDAP_PUBKEY
+#include "ldapauth.h"
+#endif
+
 static void add_listen_addr(ServerOptions *, char *, int);
 static void add_one_listen_addr(ServerOptions *, char *, int);
 
@@ -136,6 +140,26 @@
 	options->num_allow_groups = 0;
 	options->num_deny_groups = 0;
 	options->ciphers = NULL;
+#ifdef WITH_LDAP_PUBKEY
+       /* XXX dirty */
+       options->lpk.ld = NULL;
+       options->lpk.on = -1;
+       options->lpk.servers = NULL;
+       options->lpk.u_basedn = NULL;
+       options->lpk.g_basedn = NULL;
+       options->lpk.binddn = NULL;
+       options->lpk.bindpw = NULL;
+       options->lpk.sgroup = NULL;
+       options->lpk.filter = NULL;
+       options->lpk.fgroup = NULL;
+       options->lpk.l_conf = NULL;
+       options->lpk.tls = -1;
+       options->lpk.b_timeout.tv_sec = -1;
+       options->lpk.s_timeout.tv_sec = -1;
+       options->lpk.flags = FLAG_EMPTY;
+       options->lpk.pub_key_attr = NULL;
+       options->lpk.uid_attr = NULL;
+#endif
 	options->macs = NULL;
 	options->kex_algorithms = NULL;
 	options->protocol = SSH_PROTO_UNKNOWN;
@@ -353,6 +377,36 @@
 		options->fwd_opts.streamlocal_bind_unlink = 0;
 	if (options->fingerprint_hash == -1)
 		options->fingerprint_hash = SSH_FP_HASH_DEFAULT;
+#ifdef WITH_LDAP_PUBKEY
+	if (options->lpk.on == -1)
+		options->lpk.on = _DEFAULT_LPK_ON;
+	if (options->lpk.servers == NULL)
+		options->lpk.servers = _DEFAULT_LPK_SERVERS;
+	if (options->lpk.u_basedn == NULL)
+		options->lpk.u_basedn = _DEFAULT_LPK_UDN;
+	if (options->lpk.g_basedn == NULL)
+		options->lpk.g_basedn = _DEFAULT_LPK_GDN;
+	if (options->lpk.uid_attr == NULL)
+		options->lpk.uid_attr = _DEFAULT_LPK_UID;
+	if (options->lpk.binddn == NULL)
+		options->lpk.binddn = _DEFAULT_LPK_BINDDN;
+	if (options->lpk.bindpw == NULL)
+		options->lpk.bindpw = _DEFAULT_LPK_BINDPW;
+	if (options->lpk.sgroup == NULL)
+		options->lpk.sgroup = _DEFAULT_LPK_SGROUP;
+	if (options->lpk.filter == NULL)
+		options->lpk.filter = _DEFAULT_LPK_FILTER;
+	if (options->lpk.tls == -1)
+		options->lpk.tls = _DEFAULT_LPK_TLS;
+	if (options->lpk.b_timeout.tv_sec == -1)
+		options->lpk.b_timeout.tv_sec = _DEFAULT_LPK_BTIMEOUT;
+	if (options->lpk.s_timeout.tv_sec == -1)
+		options->lpk.s_timeout.tv_sec = _DEFAULT_LPK_STIMEOUT;
+	if (options->lpk.l_conf == NULL)
+		options->lpk.l_conf = _DEFAULT_LPK_LDP;
+	if (options->lpk.pub_key_attr == NULL)
+		options->lpk.pub_key_attr = _DEFAULT_LPK_PUB;
+#endif
 
 	assemble_algorithms(options);
 
@@ -431,6 +485,12 @@
 	sStreamLocalBindMask, sStreamLocalBindUnlink,
 	sAllowStreamLocalForwarding, sFingerprintHash,
 	sDeprecated, sUnsupported
+#ifdef WITH_LDAP_PUBKEY
+       ,sLdapPublickey, sLdapServers, sLdapUserDN
+       ,sLdapGroupDN, sBindDN, sBindPw, sUIDAttribute, sMyGroup
+       ,sLdapFilter, sForceTLS, sBindTimeout
+       ,sSearchTimeout, sLdapConf ,sLpkPubKeyAttr
+#endif
 } ServerOpCodes;
 
 #define SSHCFG_GLOBAL	0x01	/* allowed in main section of sshd_config */
@@ -547,6 +607,22 @@
 	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_GLOBAL },
 	{ "authorizedkeysfile", sAuthorizedKeysFile, SSHCFG_ALL },
 	{ "authorizedkeysfile2", sDeprecated, SSHCFG_ALL },
+#ifdef WITH_LDAP_PUBKEY
+	{ _DEFAULT_LPK_TOKEN, sLdapPublickey, SSHCFG_GLOBAL },
+	{ _DEFAULT_SRV_TOKEN, sLdapServers, SSHCFG_GLOBAL },
+	{ _DEFAULT_USR_TOKEN, sLdapUserDN, SSHCFG_GLOBAL },
+	{ _DEFAULT_GRP_TOKEN, sLdapGroupDN, SSHCFG_GLOBAL },
+	{ _DEFAULT_UID_TOKEN, sUIDAttribute, SSHCFG_GLOBAL },
+	{ _DEFAULT_BDN_TOKEN, sBindDN, SSHCFG_GLOBAL },
+	{ _DEFAULT_BPW_TOKEN, sBindPw, SSHCFG_GLOBAL },
+	{ _DEFAULT_MYG_TOKEN, sMyGroup, SSHCFG_GLOBAL },
+	{ _DEFAULT_FIL_TOKEN, sLdapFilter, SSHCFG_GLOBAL },
+	{ _DEFAULT_TLS_TOKEN, sForceTLS, SSHCFG_GLOBAL },
+	{ _DEFAULT_BTI_TOKEN, sBindTimeout, SSHCFG_GLOBAL },
+	{ _DEFAULT_STI_TOKEN, sSearchTimeout, SSHCFG_GLOBAL },
+	{ _DEFAULT_LDP_TOKEN, sLdapConf, SSHCFG_GLOBAL },
+	{ "LpkPubKeyAttr", sLpkPubKeyAttr, SSHCFG_GLOBAL },
+#endif
 	{ "useprivilegeseparation", sUsePrivilegeSeparation, SSHCFG_GLOBAL},
 	{ "acceptenv", sAcceptEnv, SSHCFG_ALL },
 	{ "permittunnel", sPermitTunnel, SSHCFG_ALL },
@@ -970,6 +1046,7 @@
 	int cmdline = 0, *intptr, value, value2, n, port;
 	SyslogFacility *log_facility_ptr;
 	LogLevel *log_level_ptr;
+        unsigned long lvalue, *longptr;
 	ServerOpCodes opcode;
 	u_int i, flags = 0;
 	size_t len;
@@ -985,6 +1062,7 @@
 	if (!arg || !*arg || *arg == '#')
 		return 0;
 	intptr = NULL;
+        longptr = NULL;
 	charptr = NULL;
 	opcode = parse_token(arg, filename, linenum, &flags);
 
@@ -1863,6 +1941,133 @@
 		while (arg)
 		    arg = strdelim(&cp);
 		break;
+#ifdef WITH_LDAP_PUBKEY
+       case sLdapPublickey:
+               intptr = &options->lpk.on;
+               goto parse_flag;
+       case sLdapServers:
+               /* arg = strdelim(&cp); */
+               p = line;
+               while(*p++);
+               arg = p;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing ldap server",filename,linenum);
+               arg[strlen(arg)] = '\0';
+               if ((options->lpk.servers = ldap_parse_servers(arg)) == NULL)
+                   fatal("%s line %d: error in ldap servers", filename, linenum);
+               memset(arg,0,strlen(arg));
+               break;
+       case sLdapUserDN:
+               arg = cp;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing ldap server",filename,linenum);
+               arg[strlen(arg)] = '\0';
+               options->lpk.u_basedn = xstrdup(arg);
+               memset(arg,0,strlen(arg));
+               break;
+       case sLdapGroupDN:
+               arg = cp;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing ldap server",filename,linenum);
+               arg[strlen(arg)] = '\0';
+               options->lpk.g_basedn = xstrdup(arg);
+               memset(arg,0,strlen(arg));
+               break;
+       case sUIDAttribute:
+               arg = cp;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing uid_attr",filename,linenum);
+               arg[strlen(arg)] = '\0';
+               options->lpk.uid_attr = xstrdup(arg);
+               memset(arg,0,strlen(arg));
+               break;
+       case sBindDN:
+               arg = cp;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing binddn",filename,linenum);
+               arg[strlen(arg)] = '\0';
+               options->lpk.binddn = xstrdup(arg);
+               memset(arg,0,strlen(arg));
+               break;
+       case sBindPw:
+               arg = cp;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing bindpw",filename,linenum);
+               arg[strlen(arg)] = '\0';
+               options->lpk.bindpw = xstrdup(arg);
+               memset(arg,0,strlen(arg));
+               break;
+       case sMyGroup:
+               arg = cp;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing groupname",filename, linenum);
+               arg[strlen(arg)] = '\0';
+               options->lpk.sgroup = xstrdup(arg);
+               if (options->lpk.sgroup)
+                   options->lpk.fgroup = ldap_parse_groups(options->lpk.sgroup);
+               memset(arg,0,strlen(arg));
+               break;
+       case sLdapFilter:
+               arg = cp;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing filter",filename, linenum);
+               arg[strlen(arg)] = '\0';
+               options->lpk.filter = xstrdup(arg);
+               memset(arg,0,strlen(arg));
+               break;
+       case sForceTLS:
+               intptr = &options->lpk.tls;
+               arg = strdelim(&cp);
+               if (!arg || *arg == '\0')
+                       fatal("%s line %d: missing yes/no argument.",
+                           filename, linenum);
+               value = 0;      /* silence compiler */
+               if (strcmp(arg, "yes") == 0)
+                       value = 1;
+               else if (strcmp(arg, "no") == 0)
+                       value = 0;
+               else if (strcmp(arg, "try") == 0)
+                       value = -1;
+               else
+                       fatal("%s line %d: Bad yes/no argument: %s",
+                               filename, linenum, arg);
+               if (*intptr == -1)
+                       *intptr = value;
+               break;
+       case sBindTimeout:
+               longptr = (unsigned long *) &options->lpk.b_timeout.tv_sec;
+parse_ulong:
+               arg = strdelim(&cp);
+               if (!arg || *arg == '\0')
+                       fatal("%s line %d: missing integer value.",
+                           filename, linenum);
+               lvalue = atol(arg);
+               if (*activep && *longptr == -1)
+                       *longptr = lvalue;
+               break;
+
+       case sSearchTimeout:
+               longptr = (unsigned long *) &options->lpk.s_timeout.tv_sec;
+               goto parse_ulong;
+               break;
+       case sLdapConf:
+               arg = cp;
+               if (!arg || *arg == '\0')
+                   fatal("%s line %d: missing LpkLdapConf", filename, linenum);
+               arg[strlen(arg)] = '\0';
+               options->lpk.l_conf = xstrdup(arg);
+               memset(arg, 0, strlen(arg));
+               break;
+       case sLpkPubKeyAttr:
+               arg = cp;
+                if (!arg || *arg == '\0')
+                    fatal("%s line %d: missing pubkeyattr",filename,linenum);
+                arg[strlen(arg)] = '\0';
+                options->lpk.pub_key_attr = xstrdup(arg);
+                memset(arg,0,strlen(arg));
+                break;
+
+#endif
 
 	default:
 		fatal("%s line %d: Missing handler for opcode %s (%d)",
--- openssh-7.2p1/servconf.h.orig	2016-02-28 12:41:54.415332648 +0900
+++ openssh-7.2p1/servconf.h	2016-02-28 13:29:56.547519887 +0900
@@ -16,6 +16,10 @@
 #ifndef SERVCONF_H
 #define SERVCONF_H
 
+#ifdef WITH_LDAP_PUBKEY
+#include "ldapauth.h"
+#endif
+
 #define MAX_PORTS		256	/* Max # ports. */
 
 #define MAX_ALLOW_USERS		256	/* Max # users on allow list. */
@@ -174,6 +178,9 @@
 	int	use_pam;		/* Enable auth via PAM */
 
 	int	permit_tun;
+#ifdef WITH_LDAP_PUBKEY
+        ldap_opt_t lpk;
+#endif
 
 	int	num_permitted_opens;
 
--- openssh-7.2p1/sshd.c.orig	2016-02-28 12:41:54.439332620 +0900
+++ openssh-7.2p1/sshd.c	2016-02-28 13:32:26.715356557 +0900
@@ -125,6 +125,10 @@
 #include "version.h"
 #include "ssherr.h"
 
+#ifdef WITH_LDAP_PUBKEY
+#include "ldapauth.h"
+#endif
+
 #ifndef O_NOCTTY
 #define O_NOCTTY	0
 #endif
@@ -1744,6 +1748,16 @@
 		exit(1);
 	}
 
+#ifdef WITH_LDAP_PUBKEY
+    /* ldap_options_print(&options.lpk); */
+    /* XXX initialize/check ldap connection and set *LD */
+    if (options.lpk.on) {
+        if (options.lpk.l_conf && (ldap_parse_lconf(&options.lpk) < 0) )
+            error("[LDAP] could not parse %s", options.lpk.l_conf);
+        if (ldap_connect(&options.lpk) < 0)
+            error("[LDAP] could not initialize ldap connection");
+    }
+#endif
 	debug("sshd version %s, %s", SSH_VERSION,
 #ifdef WITH_OPENSSL
 	    SSLeay_version(SSLEAY_VERSION)
--- openssh-7.2p1/sshd_config.5.orig	2016-02-28 12:41:54.443332618 +0900
+++ openssh-7.2p1/sshd_config.5	2016-02-28 13:34:26.163227019 +0900
@@ -1684,6 +1684,62 @@
 to not use one.
 The default is
 .Pa /usr/X11R6/bin/xauth .
+.It Cm UseLPK
+Specifies whether LDAP public key retrieval must be used or not. It allow
+an easy centralisation of public keys within an LDAP directory. The argument must be
+.Dq yes
+or
+.Dq no .
+.It Cm LpkLdapConf
+Specifies whether LDAP Public keys should parse the specified ldap.conf file
+instead of sshd_config Tokens. The argument must be a valid path to an ldap.conf
+file like
+.Pa /etc/ldap.conf
+.It Cm LpkServers
+Specifies LDAP one or more [:space:] separated server's url the following form may be used:
+.Pp
+LpkServers ldaps://127.0.0.1 ldap://127.0.0.2 ldap://127.0.0.3
+.It Cm LpkUserDN
+Specifies the LDAP user DN.
+.Pp
+LpkUserDN ou=users,dc=phear,dc=org
+.It Cm LpkGroupDN
+Specifies the LDAP groups DN.
+.Pp
+LpkGroupDN ou=groups,dc=phear,dc=org
+.It Cm LpkBindDN
+Specifies the LDAP bind DN to use if necessary.
+.Pp
+LpkBindDN cn=Manager,dc=phear,dc=org
+.It Cm LpkBindPw
+Specifies the LDAP bind credential.
+.Pp
+LpkBindPw secret
+.It Cm LpkServerGroup
+Specifies one or more [:space:] separated group the server is part of.
+.Pp
+LpkServerGroup unix mail prod
+.It Cm LpkFilter
+Specifies an additional LDAP filter to use for finding SSH keys
+.Pp
+LpkFilter (hostAccess=master.phear.org)
+.It Cm LpkForceTLS
+Specifies if the LDAP server connection must be tried, forced or not used. The argument must be
+.Dq yes
+or
+.Dq no
+or
+.Dq try .
+.It Cm LpkSearchTimelimit
+Sepcifies the search time limit before the search is considered over. value is
+in seconds.
+.Pp
+LpkSearchTimelimit 3
+.It Cm LpkBindTimelimit
+Sepcifies the bind time limit before the connection is considered dead. value is
+in seconds.
+.Pp
+LpkBindTimelimit 3
 .El
 .Sh TIME FORMATS
 .Xr sshd 8
--- openssh-7.2p1/sshd_config.orig	2016-02-28 12:41:54.443332618 +0900
+++ openssh-7.2p1/sshd_config	2016-02-28 13:33:12.059307281 +0900
@@ -122,6 +122,22 @@
 # no default banner path
 #Banner none
 
+# here are the new patched ldap related tokens
+# entries in your LDAP must have posixAccount & ldapPublicKey objectclass
+#UseLPK yes
+#LpkLdapConf /etc/ldap.conf
+#LpkServers  ldap://10.1.7.1/ ldap://10.1.7.2/
+#LpkUserDN   ou=users,dc=phear,dc=org
+#LpkGroupDN  ou=groups,dc=phear,dc=org
+#LpkBindDN cn=Manager,dc=phear,dc=org
+#LpkBindPw secret
+#LpkServerGroup mail
+#LpkFilter (hostAccess=master.phear.org)
+#LpkForceTLS no
+#LpkSearchTimelimit 3
+#LpkBindTimelimit 3
+#LpkPubKeyAttr sshPublicKey
+
 # override default of no subsystems
 Subsystem	sftp	/usr/libexec/sftp-server
 
--- openssh-7.2p1/version.h.orig	2016-02-28 12:41:54.447332615 +0900
+++ openssh-7.2p1/version.h	2016-02-28 13:36:29.719091723 +0900
@@ -3,4 +3,5 @@
 #define SSH_VERSION	"OpenSSH_7.2"
 
 #define SSH_PORTABLE	"p1"
-#define SSH_RELEASE	SSH_VERSION SSH_PORTABLE
+#define SSH_LPK         "lpk"
+#define SSH_RELEASE	SSH_VERSION SSH_PORTABLE SSH_LPK
